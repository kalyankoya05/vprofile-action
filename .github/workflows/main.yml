name: vprofile-actions
on: workflow_dispatch
env:
  AWS_REGION: "ap-south-1"
  ECR_REPOSITORY: "vprofileapp"
  EKS_CLUSTER: "vprofile-eks"

jobs:
  Testing:
    name: Testing the code
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Maven test
        run: mvn test

      - name: Checkstyle
        run: mvn checkstyle:checkstyle

      - name: Set up JDK 11
        uses: actions/setup-java@v3
        with:
          distribution: temurin
          java-version: "11"

      - name: Set up Sonar-Scanner
        uses: warchant/setup-sonar-scanner@v7

      - name: SonarQube Scan
        env:
          SONAR_HOST_URL: ${{ secrets.SONAR_URL }}
          SONAR_LOGIN: ${{ secrets.SONAR_TOKEN }}
          SONAR_ORGANIZATION: ${{ secrets.SONAR_ORGANIZATION }}
          SONAR_PROJECT_KEY: ${{ secrets.SONAR_PROJECT_KEY }}
        run: |
          # verify secret presence (masked)
          if [ -z "${SONAR_HOST_URL:-}" ]; then echo "SONAR_HOST_URL missing" && exit 1; fi
          sonar-scanner \
            -Dsonar.host.url="${SONAR_HOST_URL}" \
            -Dsonar.login="${SONAR_LOGIN}" \
            -Dsonar.organization="${SONAR_ORGANIZATION}" \
            -Dsonar.projectKey="${SONAR_PROJECT_KEY}" \
            -Dsonar.sources=src/ \
            -Dsonar.junit.reportPaths=target/surefire-reports/ \
            -Dsonar.jacoco.reportPaths=target/jacoco.exec \
            -Dsonar.java.checkstyle.reportPaths=target/checkstyle-result.xml \
            -Dsonar.java.binaries=target/test-classes/com/visualpathit/account

      - name: SonarQube quality gate check
        id: sonarqube-quality-gate-check
        uses: sonarsource/sonarqube-quality-gate-action@master
        timeout-minutes: 5
        env:
          SONAR_HOST_URL: ${{ secrets.SONAR_URL }}
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
        with:
          scanMetadataReportFile: .scannerwork/report-task.txt
          pollingTimeoutSec: 300

  BUILD_AND_PUBLISH:
    needs: Testing
    runs-on: ubuntu-latest
    permissions:
      contents: read

    env:
      AWS_REGION: ap-south-1
      ECR_REPOSITORY: vprofileapp

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Verify AWS secrets present
        run: |
          echo "AWS_ACCESS_KEY_ID present: ${AWS_ACCESS_KEY_ID:+yes}"
          echo "AWS_SECRET_ACCESS_KEY present: ${AWS_SECRET_ACCESS_KEY:+yes}"
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Verify caller identity
        run: aws sts get-caller-identity --output json

      - name: Determine ECR registry and create repo if missing
        id: ecr
        run: |
          # Compute registry from caller identity
          ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          ECR_REGISTRY="${ACCOUNT_ID}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com"
          # if you provided a REGISTRY secret (full host) use it as fallback
          if [ -n "${{ secrets.REGISTRY }}" ] && [ -z "${ECR_REGISTRY:-}" ]; then
            ECR_REGISTRY="${{ secrets.REGISTRY }}"
          fi
          echo "ECR_REGISTRY=$ECR_REGISTRY" >> $GITHUB_ENV
          # create repo if missing
          aws ecr describe-repositories --repository-names "${{ env.ECR_REPOSITORY }}" >/dev/null 2>&1 || \
            aws ecr create-repository --repository-name "${{ env.ECR_REPOSITORY }}" --image-scanning-configuration scanOnPush=true || true

      - name: Login to ECR
        run: |
          aws ecr get-login-password --region ${{ env.AWS_REGION }} | docker login --username AWS --password-stdin "${ECR_REGISTRY}"

      - name: Build image
        run: |
          set -euo pipefail
          # robust tag fallback: run number -> run id -> short sha
          TAG="${GITHUB_RUN_NUMBER:-}"
          if [ -z "$TAG" ]; then
            TAG="${GITHUB_RUN_ID:-}"
          fi
          if [ -z "$TAG" ]; then
            TAG="${GITHUB_SHA:-}"
            TAG="${TAG:0:7}"
          fi

          # use computed registry or REGISTRY secret
          if [ -z "${ECR_REGISTRY:-}" ] && [ -n "${{ secrets.REGISTRY }}" ]; then
            ECR_REGISTRY="${{ secrets.REGISTRY }}"
          fi

          # trim whitespace
          ECR_REGISTRY="${ECR_REGISTRY//[$'\t\r\n ']}"
          REPO="${ECR_REPOSITORY//[$'\t\r\n ']}"

          IMAGE="${ECR_REGISTRY}/${REPO}"

          # export stable values for later steps
          echo "IMAGE=${IMAGE}" >> "$GITHUB_ENV"
          echo "TAG=${TAG}" >> "$GITHUB_ENV"

          echo "Computed IMAGE=${IMAGE}:${TAG}"
          if [[ -z "$ECR_REGISTRY" || -z "$REPO" || -z "$TAG" ]]; then
            echo "ERROR: ECR_REGISTRY, REPO or TAG empty"
            echo "ECR_REGISTRY='${ECR_REGISTRY}'"
            echo "REPO='${REPO}'"
            echo "TAG='${TAG}'"
            exit 1
          fi

          docker build -f ./Dockerfile -t "${IMAGE}:latest" -t "${IMAGE}:${TAG}" .
          echo "Built images (top results):"
          docker images --format "table {{.Repository}}\t{{.Tag}}\t{{.Size}}" | sed -n "1,20p"

      - name: Push image
        run: |
          set -euo pipefail
          # consume the exact values produced by Build step
          IMAGE="${IMAGE:-}"
          TAG="${TAG:-}"
          echo "Pushing IMAGE='${IMAGE}' TAG='${TAG}'"
          if [[ -z "$IMAGE" || -z "$TAG" ]]; then
            echo "ERROR: IMAGE or TAG is empty. Aborting."
            exit 1
          fi
          # debug: show local image entries
          docker images "${IMAGE}" --format "table {{.Repository}}\t{{.Tag}}\t{{.ID}}" || true
          docker push "${IMAGE}:${TAG}"
          docker push "${IMAGE}:latest"

  DeployToEKS:
    needs: BUILD_AND_PUBLISH
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Verify caller identity
        run: aws sts get-caller-identity --output json

      - name: Update kubeconfig
        run: |
          aws eks update-kubeconfig --name ${{ env.EKS_CLUSTER }} --region ${{ env.AWS_REGION }}

      - name: Create image pull secret in cluster
        run: |
          # use REGISTRY secret if set; otherwise use computed registry from previous job
          REGISTRY_HOST="${{ secrets.REGISTRY }}"
          if [ -z "$REGISTRY_HOST" ]; then
            REGISTRY_HOST="${ECR_REGISTRY:-}"
          fi
          kubectl create secret docker-registry regcred \
            --docker-server="${REGISTRY_HOST}" \
            --docker-username=AWS \
            --docker-password="$(aws ecr get-login-password --region ${{ env.AWS_REGION }})" || true

      - name: Verify kubectl access
        run: kubectl get nodes

      - name: Deploy to Helm
        uses: bitovi/github-actions-deploy-eks-helm@v1.2.8
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
          cluster-name: ${{ env.EKS_CLUSTER }}
          chart-path: ./helm/vprofilecharts
          namespace: default
          # pass image and tag to Helm chart values (image.repository/image.tag or appimage/apptag depending on your template)
          values: |
            image.repository=${{ env.ECR_REGISTRY }}/{{ env.ECR_REPOSITORY }}
            image.tag=${{ github.run_number }}
          name: vprofile-stack
